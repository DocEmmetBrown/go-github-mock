package main

import (
	"bytes"
	"flag"
	"fmt"
	"io/ioutil"
	"os"

	"net/http"
	"os/exec"
	"strings"

	"github.com/PuerkitoBio/goquery"

	"github.com/go-kit/log"
	"github.com/go-kit/log/level"
)

const BASE_URL = "https://docs.github.com"

const GITHUB_REST_API_URL = "https://docs.github.com/en/rest"

const OUTPUT_FILE_HEADER = `package mock

// Code generated by main.go; DO NOT EDIT.

`
const OUTPUT_FILEPATH = "src/mock/endpointpattern.go"

type ScrapeResult struct {
	HTTPMethod      string
	EndpointPattern string
}

var debug bool

func init() {
	flag.BoolVar(&debug, "debug", false, "output debug information")
}

func getGoQueryDocumentFromUrl(l log.Logger, urlToScrape string) (*goquery.Document, error) {
	res, err := http.Get(urlToScrape)
	if err != nil {
		level.Error(l).Log(err)
		os.Exit(1)
	}
	defer res.Body.Close()
	if res.StatusCode != 200 {
		level.Error(l).Log("status code error: %d %s", res.StatusCode, res.Status)
		os.Exit(1)
	}

	doc, err := goquery.NewDocumentFromReader(res.Body)
	if err != nil {
		level.Error(l).Log(err)
		os.Exit(1)
	}

	return doc, err
}

func scrapeReferenceTab(l log.Logger) []string {
	doc, err := getGoQueryDocumentFromUrl(l, GITHUB_REST_API_URL)

	if err != nil {
		level.Error(l).Log(err)
		os.Exit(1)
	}

	restEndpoints := []string{}

	doc.Find("#__next > div > div > nav > ul > li:nth-child(3) > ul > li:nth-child(2) > details > ul > li > a").
		Each(func(i int, s *goquery.Selection) {
			if v, ok := s.Attr("href"); ok {
				restEndpoints = append(restEndpoints, fmt.Sprintf("%s%s", BASE_URL, v))
			}
		})

	return restEndpoints
}

func scrapeApiReference(l log.Logger, url string) <-chan ScrapeResult {
	scrapedEndpoints := make(chan ScrapeResult)

	go func() {
		doc, err := getGoQueryDocumentFromUrl(l, url)
		if err != nil {
			level.Error(l).Log(err)
			os.Exit(1)
		}

		doc.Find("#article-contents > div > pre > code").Each(
			func(i int, s *goquery.Selection) {
				combinedInnerTextSplit := strings.Split(
					s.Text(),
					" ",
				)

				scrapedEndpoints <- ScrapeResult{
					HTTPMethod:      combinedInnerTextSplit[0],
					EndpointPattern: combinedInnerTextSplit[1],
				}
			},
		)

		close(scrapedEndpoints)
	}()

	return scrapedEndpoints
}

// formatToGolangVarName generated the proper golang variable name
// given a endpoint format from the API
func formatToGolangVarName(l log.Logger, sr ScrapeResult) string {
	// handles urls with dashes in them
	pattern := strings.ReplaceAll(sr.EndpointPattern, "-", "/")

	epSplit := strings.Split(
		pattern,
		"/",
	)

	result := ""

	// handle the first part of the variable name
	for _, part := range epSplit {
		if len(part) < 1 || string(part[0]) == "{" {
			continue
		}

		splitPart := strings.Split(part, "_")

		for _, p := range splitPart {
			result = result + strings.Title(p)
		}
	}

	//handle the "By`X`" part of the variable name
	for _, part := range epSplit {
		if len(part) < 1 {
			continue
		}

		if string(part[0]) == "{" {
			part = strings.ReplaceAll(part, "{", "")
			part = strings.ReplaceAll(part, "}", "")

			result += "By"

			for _, splitPart := range strings.Split(part, "_") {
				result += strings.Title(splitPart)
			}
		}
	}

	return strings.Title(strings.ToLower(sr.HTTPMethod)) + result
}

func formatToGolangVarNameAndValue(l log.Logger, lsr ScrapeResult) string {
	return fmt.Sprintf(
		`var %s EndpointPattern = EndpointPattern{
	Pattern: "%s",
	Method:  "%s",
}
`,
		formatToGolangVarName(l, lsr),
		lsr.EndpointPattern,
		strings.ToUpper(lsr.HTTPMethod),
	) + "\n"
}

func main() {
	flag.Parse()

	var l log.Logger

	l = log.NewLogfmtLogger(log.NewSyncWriter(os.Stdout))

	l = log.With(l, "caller", log.DefaultCaller)

	l = level.NewFilter(l, level.AllowInfo())

	if debug {
		l = level.NewFilter(l, level.AllowDebug())
	}

	referenceUrlsToScrape := scrapeReferenceTab(l)

	buf := bytes.NewBuffer([]byte(OUTPUT_FILE_HEADER))

	for _, url := range referenceUrlsToScrape {
		res := scrapeApiReference(l, url)

		for r := range res {
			buf.WriteString(formatToGolangVarNameAndValue(l, r))
		}
	}

	ioutil.WriteFile(
		OUTPUT_FILEPATH,
		buf.Bytes(),
		0755,
	)

	errorsFound := false

	// to catch possible format errors
	if err := exec.Command("gofmt", "-w", "src/mock/endpointpattern.go").Run(); err != nil {
		level.Error(l).Log(fmt.Sprintf("error executing gofmt: %s", err.Error()))
		errorsFound = true
	}

	// to catch everything else (hopefully)
	if err := exec.Command("go", "vet", "src/mock/endpointpattern.go").Run(); err != nil {
		level.Error(l).Log(fmt.Sprintf("error executing go vet: %s", err.Error()))
		errorsFound = true
	}

	if errorsFound {
		os.Exit(1)
	}
}
